import {
  require_multiplex
} from "./chunk-Y2SFBU6W.js";
import {
  require_codemirror
} from "./chunk-GI5J7NWS.js";
import {
  __commonJS
} from "./chunk-WGAPYIUP.js";

// node_modules/.pnpm/codemirror@5.65.16/node_modules/codemirror/mode/twig/twig.js
var require_twig = __commonJS({
  "node_modules/.pnpm/codemirror@5.65.16/node_modules/codemirror/mode/twig/twig.js"(exports, module) {
    (function(mod) {
      if (typeof exports == "object" && typeof module == "object")
        mod(require_codemirror(), require_multiplex());
      else if (typeof define == "function" && define.amd)
        define(["../../lib/codemirror", "../../addon/mode/multiplex"], mod);
      else
        mod(CodeMirror);
    })(function(CodeMirror2) {
      "use strict";
      CodeMirror2.defineMode("twig:inner", function() {
        var keywords = ["and", "as", "autoescape", "endautoescape", "block", "do", "endblock", "else", "elseif", "extends", "for", "endfor", "embed", "endembed", "filter", "endfilter", "flush", "from", "if", "endif", "in", "is", "include", "import", "not", "or", "set", "spaceless", "endspaceless", "with", "endwith", "trans", "endtrans", "blocktrans", "endblocktrans", "macro", "endmacro", "use", "verbatim", "endverbatim"], operator = /^[+\-*&%=<>!?|~^]/, sign = /^[:\[\(\{]/, atom = ["true", "false", "null", "empty", "defined", "divisibleby", "divisible by", "even", "odd", "iterable", "sameas", "same as"], number = /^(\d[+\-\*\/])?\d+(\.\d+)?/;
        keywords = new RegExp("((" + keywords.join(")|(") + "))\\b");
        atom = new RegExp("((" + atom.join(")|(") + "))\\b");
        function tokenBase(stream, state) {
          var ch = stream.peek();
          if (state.incomment) {
            if (!stream.skipTo("#}")) {
              stream.skipToEnd();
            } else {
              stream.eatWhile(/\#|}/);
              state.incomment = false;
            }
            return "comment";
          } else if (state.intag) {
            if (state.operator) {
              state.operator = false;
              if (stream.match(atom)) {
                return "atom";
              }
              if (stream.match(number)) {
                return "number";
              }
            }
            if (state.sign) {
              state.sign = false;
              if (stream.match(atom)) {
                return "atom";
              }
              if (stream.match(number)) {
                return "number";
              }
            }
            if (state.instring) {
              if (ch == state.instring) {
                state.instring = false;
              }
              stream.next();
              return "string";
            } else if (ch == "'" || ch == '"') {
              state.instring = ch;
              stream.next();
              return "string";
            } else if (stream.match(state.intag + "}") || stream.eat("-") && stream.match(state.intag + "}")) {
              state.intag = false;
              return "tag";
            } else if (stream.match(operator)) {
              state.operator = true;
              return "operator";
            } else if (stream.match(sign)) {
              state.sign = true;
            } else {
              if (stream.eat(" ") || stream.sol()) {
                if (stream.match(keywords)) {
                  return "keyword";
                }
                if (stream.match(atom)) {
                  return "atom";
                }
                if (stream.match(number)) {
                  return "number";
                }
                if (stream.sol()) {
                  stream.next();
                }
              } else {
                stream.next();
              }
            }
            return "variable";
          } else if (stream.eat("{")) {
            if (stream.eat("#")) {
              state.incomment = true;
              if (!stream.skipTo("#}")) {
                stream.skipToEnd();
              } else {
                stream.eatWhile(/\#|}/);
                state.incomment = false;
              }
              return "comment";
            } else if (ch = stream.eat(/\{|%/)) {
              state.intag = ch;
              if (ch == "{") {
                state.intag = "}";
              }
              stream.eat("-");
              return "tag";
            }
          }
          stream.next();
        }
        ;
        return {
          startState: function() {
            return {};
          },
          token: function(stream, state) {
            return tokenBase(stream, state);
          }
        };
      });
      CodeMirror2.defineMode("twig", function(config, parserConfig) {
        var twigInner = CodeMirror2.getMode(config, "twig:inner");
        if (!parserConfig || !parserConfig.base)
          return twigInner;
        return CodeMirror2.multiplexingMode(
          CodeMirror2.getMode(config, parserConfig.base),
          {
            open: /\{[{#%]/,
            close: /[}#%]\}/,
            mode: twigInner,
            parseDelimiters: true
          }
        );
      });
      CodeMirror2.defineMIME("text/x-twig", "twig");
    });
  }
});
export default require_twig();
//# sourceMappingURL=codemirror_mode_twig_twig.js.map
