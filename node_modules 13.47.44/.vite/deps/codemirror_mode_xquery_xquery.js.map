{
  "version": 3,
  "sources": ["../../.pnpm/codemirror@5.65.16/node_modules/codemirror/mode/xquery/xquery.js"],
  "sourcesContent": ["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"xquery\", function() {\n\n  // The keywords object is set to the result of this self executing\n  // function. Each keyword is a property of the keywords object whose\n  // value is {type: atype, style: astyle}\n  var keywords = function(){\n    // convenience functions used to build keywords object\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var operator = kw(\"operator\")\n      , atom = {type: \"atom\", style: \"atom\"}\n      , punctuation = {type: \"punctuation\", style: null}\n      , qualifier = {type: \"axis_specifier\", style: \"qualifier\"};\n\n    // kwObj is what is return from this function at the end\n    var kwObj = {\n      ',': punctuation\n    };\n\n    // a list of 'basic' keywords. For each add a property to kwObj with the value of\n    // {type: basic[i], style: \"keyword\"} e.g. 'after' --> {type: \"after\", style: \"keyword\"}\n    var basic = ['after', 'all', 'allowing', 'ancestor', 'ancestor-or-self', 'any', 'array', 'as',\n    'ascending', 'at', 'attribute', 'base-uri', 'before', 'boundary-space', 'by', 'case', 'cast',\n    'castable', 'catch', 'child', 'collation', 'comment', 'construction', 'contains', 'content',\n    'context', 'copy', 'copy-namespaces', 'count', 'decimal-format', 'declare', 'default', 'delete',\n    'descendant', 'descendant-or-self', 'descending', 'diacritics', 'different', 'distance',\n    'document', 'document-node', 'element', 'else', 'empty', 'empty-sequence', 'encoding', 'end',\n    'entire', 'every', 'exactly', 'except', 'external', 'first', 'following', 'following-sibling',\n    'for', 'from', 'ftand', 'ftnot', 'ft-option', 'ftor', 'function', 'fuzzy', 'greatest', 'group',\n    'if', 'import', 'in', 'inherit', 'insensitive', 'insert', 'instance', 'intersect', 'into',\n    'invoke', 'is', 'item', 'language', 'last', 'lax', 'least', 'let', 'levels', 'lowercase', 'map',\n    'modify', 'module', 'most', 'namespace', 'next', 'no', 'node', 'nodes', 'no-inherit',\n    'no-preserve', 'not', 'occurs', 'of', 'only', 'option', 'order', 'ordered', 'ordering',\n    'paragraph', 'paragraphs', 'parent', 'phrase', 'preceding', 'preceding-sibling', 'preserve',\n    'previous', 'processing-instruction', 'relationship', 'rename', 'replace', 'return',\n    'revalidation', 'same', 'satisfies', 'schema', 'schema-attribute', 'schema-element', 'score',\n    'self', 'sensitive', 'sentence', 'sentences', 'sequence', 'skip', 'sliding', 'some', 'stable',\n    'start', 'stemming', 'stop', 'strict', 'strip', 'switch', 'text', 'then', 'thesaurus', 'times',\n    'to', 'transform', 'treat', 'try', 'tumbling', 'type', 'typeswitch', 'union', 'unordered',\n    'update', 'updating', 'uppercase', 'using', 'validate', 'value', 'variable', 'version',\n    'weight', 'when', 'where', 'wildcards', 'window', 'with', 'without', 'word', 'words', 'xquery'];\n    for(var i=0, l=basic.length; i < l; i++) { kwObj[basic[i]] = kw(basic[i]);};\n\n    // a list of types. For each add a property to kwObj with the value of\n    // {type: \"atom\", style: \"atom\"}\n    var types = ['xs:anyAtomicType', 'xs:anySimpleType', 'xs:anyType', 'xs:anyURI',\n    'xs:base64Binary', 'xs:boolean', 'xs:byte', 'xs:date', 'xs:dateTime', 'xs:dateTimeStamp',\n    'xs:dayTimeDuration', 'xs:decimal', 'xs:double', 'xs:duration', 'xs:ENTITIES', 'xs:ENTITY',\n    'xs:float', 'xs:gDay', 'xs:gMonth', 'xs:gMonthDay', 'xs:gYear', 'xs:gYearMonth', 'xs:hexBinary',\n    'xs:ID', 'xs:IDREF', 'xs:IDREFS', 'xs:int', 'xs:integer', 'xs:item', 'xs:java', 'xs:language',\n    'xs:long', 'xs:Name', 'xs:NCName', 'xs:negativeInteger', 'xs:NMTOKEN', 'xs:NMTOKENS',\n    'xs:nonNegativeInteger', 'xs:nonPositiveInteger', 'xs:normalizedString', 'xs:NOTATION',\n    'xs:numeric', 'xs:positiveInteger', 'xs:precisionDecimal', 'xs:QName', 'xs:short', 'xs:string',\n    'xs:time', 'xs:token', 'xs:unsignedByte', 'xs:unsignedInt', 'xs:unsignedLong',\n    'xs:unsignedShort', 'xs:untyped', 'xs:untypedAtomic', 'xs:yearMonthDuration'];\n    for(var i=0, l=types.length; i < l; i++) { kwObj[types[i]] = atom;};\n\n    // each operator will add a property to kwObj with value of {type: \"operator\", style: \"keyword\"}\n    var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];\n    for(var i=0, l=operators.length; i < l; i++) { kwObj[operators[i]] = operator;};\n\n    // each axis_specifiers will add a property to kwObj with value of {type: \"axis_specifier\", style: \"qualifier\"}\n    var axis_specifiers = [\"self::\", \"attribute::\", \"child::\", \"descendant::\", \"descendant-or-self::\", \"parent::\",\n    \"ancestor::\", \"ancestor-or-self::\", \"following::\", \"preceding::\", \"following-sibling::\", \"preceding-sibling::\"];\n    for(var i=0, l=axis_specifiers.length; i < l; i++) { kwObj[axis_specifiers[i]] = qualifier; };\n\n    return kwObj;\n  }();\n\n  function chain(stream, state, f) {\n    state.tokenize = f;\n    return f(stream, state);\n  }\n\n  // the primary mode tokenizer\n  function tokenBase(stream, state) {\n    var ch = stream.next(),\n        mightBeFunction = false,\n        isEQName = isEQNameAhead(stream);\n\n    // an XML tag (if not in some sub, chained tokenizer)\n    if (ch == \"<\") {\n      if(stream.match(\"!--\", true))\n        return chain(stream, state, tokenXMLComment);\n\n      if(stream.match(\"![CDATA\", false)) {\n        state.tokenize = tokenCDATA;\n        return \"tag\";\n      }\n\n      if(stream.match(\"?\", false)) {\n        return chain(stream, state, tokenPreProcessing);\n      }\n\n      var isclose = stream.eat(\"/\");\n      stream.eatSpace();\n      var tagName = \"\", c;\n      while ((c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/))) tagName += c;\n\n      return chain(stream, state, tokenTag(tagName, isclose));\n    }\n    // start code block\n    else if(ch == \"{\") {\n      pushStateStack(state, { type: \"codeblock\"});\n      return null;\n    }\n    // end code block\n    else if(ch == \"}\") {\n      popStateStack(state);\n      return null;\n    }\n    // if we're in an XML block\n    else if(isInXmlBlock(state)) {\n      if(ch == \">\")\n        return \"tag\";\n      else if(ch == \"/\" && stream.eat(\">\")) {\n        popStateStack(state);\n        return \"tag\";\n      }\n      else\n        return \"variable\";\n    }\n    // if a number\n    else if (/\\d/.test(ch)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:E[+\\-]?\\d+)?/);\n      return \"atom\";\n    }\n    // comment start\n    else if (ch === \"(\" && stream.eat(\":\")) {\n      pushStateStack(state, { type: \"comment\"});\n      return chain(stream, state, tokenComment);\n    }\n    // quoted string\n    else if (!isEQName && (ch === '\"' || ch === \"'\"))\n      return chain(stream, state, tokenString(ch));\n    // variable\n    else if(ch === \"$\") {\n      return chain(stream, state, tokenVariable);\n    }\n    // assignment\n    else if(ch ===\":\" && stream.eat(\"=\")) {\n      return \"keyword\";\n    }\n    // open paren\n    else if(ch === \"(\") {\n      pushStateStack(state, { type: \"paren\"});\n      return null;\n    }\n    // close paren\n    else if(ch === \")\") {\n      popStateStack(state);\n      return null;\n    }\n    // open paren\n    else if(ch === \"[\") {\n      pushStateStack(state, { type: \"bracket\"});\n      return null;\n    }\n    // close paren\n    else if(ch === \"]\") {\n      popStateStack(state);\n      return null;\n    }\n    else {\n      var known = keywords.propertyIsEnumerable(ch) && keywords[ch];\n\n      // if there's a EQName ahead, consume the rest of the string portion, it's likely a function\n      if(isEQName && ch === '\\\"') while(stream.next() !== '\"'){}\n      if(isEQName && ch === '\\'') while(stream.next() !== '\\''){}\n\n      // gobble up a word if the character is not known\n      if(!known) stream.eatWhile(/[\\w\\$_-]/);\n\n      // gobble a colon in the case that is a lib func type call fn:doc\n      var foundColon = stream.eat(\":\");\n\n      // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier\n      // which should get matched as a keyword\n      if(!stream.eat(\":\") && foundColon) {\n        stream.eatWhile(/[\\w\\$_-]/);\n      }\n      // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)\n      if(stream.match(/^[ \\t]*\\(/, false)) {\n        mightBeFunction = true;\n      }\n      // is the word a keyword?\n      var word = stream.current();\n      known = keywords.propertyIsEnumerable(word) && keywords[word];\n\n      // if we think it's a function call but not yet known,\n      // set style to variable for now for lack of something better\n      if(mightBeFunction && !known) known = {type: \"function_call\", style: \"variable def\"};\n\n      // if the previous word was element, attribute, axis specifier, this word should be the name of that\n      if(isInXmlConstructor(state)) {\n        popStateStack(state);\n        return \"variable\";\n      }\n      // as previously checked, if the word is element,attribute, axis specifier, call it an \"xmlconstructor\" and\n      // push the stack so we know to look for it on the next word\n      if(word == \"element\" || word == \"attribute\" || known.type == \"axis_specifier\") pushStateStack(state, {type: \"xmlconstructor\"});\n\n      // if the word is known, return the details of that else just call this a generic 'word'\n      return known ? known.style : \"variable\";\n    }\n  }\n\n  // handle comments, including nested\n  function tokenComment(stream, state) {\n    var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;\n    while (ch = stream.next()) {\n      if (ch == \")\" && maybeEnd) {\n        if(nestedCount > 0)\n          nestedCount--;\n        else {\n          popStateStack(state);\n          break;\n        }\n      }\n      else if(ch == \":\" && maybeNested) {\n        nestedCount++;\n      }\n      maybeEnd = (ch == \":\");\n      maybeNested = (ch == \"(\");\n    }\n\n    return \"comment\";\n  }\n\n  // tokenizer for string literals\n  // optionally pass a tokenizer function to set state.tokenize back to when finished\n  function tokenString(quote, f) {\n    return function(stream, state) {\n      var ch;\n\n      if(isInString(state) && stream.current() == quote) {\n        popStateStack(state);\n        if(f) state.tokenize = f;\n        return \"string\";\n      }\n\n      pushStateStack(state, { type: \"string\", name: quote, tokenize: tokenString(quote, f) });\n\n      // if we're in a string and in an XML block, allow an embedded code block\n      if(stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n        state.tokenize = tokenBase;\n        return \"string\";\n      }\n\n\n      while (ch = stream.next()) {\n        if (ch ==  quote) {\n          popStateStack(state);\n          if(f) state.tokenize = f;\n          break;\n        }\n        else {\n          // if we're in a string and in an XML block, allow an embedded code block in an attribute\n          if(stream.match(\"{\", false) && isInXmlAttributeBlock(state)) {\n            state.tokenize = tokenBase;\n            return \"string\";\n          }\n\n        }\n      }\n\n      return \"string\";\n    };\n  }\n\n  // tokenizer for variables\n  function tokenVariable(stream, state) {\n    var isVariableChar = /[\\w\\$_-]/;\n\n    // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote\n    if(stream.eat(\"\\\"\")) {\n      while(stream.next() !== '\\\"'){};\n      stream.eat(\":\");\n    } else {\n      stream.eatWhile(isVariableChar);\n      if(!stream.match(\":=\", false)) stream.eat(\":\");\n    }\n    stream.eatWhile(isVariableChar);\n    state.tokenize = tokenBase;\n    return \"variable\";\n  }\n\n  // tokenizer for XML tags\n  function tokenTag(name, isclose) {\n    return function(stream, state) {\n      stream.eatSpace();\n      if(isclose && stream.eat(\">\")) {\n        popStateStack(state);\n        state.tokenize = tokenBase;\n        return \"tag\";\n      }\n      // self closing tag without attributes?\n      if(!stream.eat(\"/\"))\n        pushStateStack(state, { type: \"tag\", name: name, tokenize: tokenBase});\n      if(!stream.eat(\">\")) {\n        state.tokenize = tokenAttribute;\n        return \"tag\";\n      }\n      else {\n        state.tokenize = tokenBase;\n      }\n      return \"tag\";\n    };\n  }\n\n  // tokenizer for XML attributes\n  function tokenAttribute(stream, state) {\n    var ch = stream.next();\n\n    if(ch == \"/\" && stream.eat(\">\")) {\n      if(isInXmlAttributeBlock(state)) popStateStack(state);\n      if(isInXmlBlock(state)) popStateStack(state);\n      return \"tag\";\n    }\n    if(ch == \">\") {\n      if(isInXmlAttributeBlock(state)) popStateStack(state);\n      return \"tag\";\n    }\n    if(ch == \"=\")\n      return null;\n    // quoted string\n    if (ch == '\"' || ch == \"'\")\n      return chain(stream, state, tokenString(ch, tokenAttribute));\n\n    if(!isInXmlAttributeBlock(state))\n      pushStateStack(state, { type: \"attribute\", tokenize: tokenAttribute});\n\n    stream.eat(/[a-zA-Z_:]/);\n    stream.eatWhile(/[-a-zA-Z0-9_:.]/);\n    stream.eatSpace();\n\n    // the case where the attribute has not value and the tag was closed\n    if(stream.match(\">\", false) || stream.match(\"/\", false)) {\n      popStateStack(state);\n      state.tokenize = tokenBase;\n    }\n\n    return \"attribute\";\n  }\n\n  // handle comments, including nested\n  function tokenXMLComment(stream, state) {\n    var ch;\n    while (ch = stream.next()) {\n      if (ch == \"-\" && stream.match(\"->\", true)) {\n        state.tokenize = tokenBase;\n        return \"comment\";\n      }\n    }\n  }\n\n\n  // handle CDATA\n  function tokenCDATA(stream, state) {\n    var ch;\n    while (ch = stream.next()) {\n      if (ch == \"]\" && stream.match(\"]\", true)) {\n        state.tokenize = tokenBase;\n        return \"comment\";\n      }\n    }\n  }\n\n  // handle preprocessing instructions\n  function tokenPreProcessing(stream, state) {\n    var ch;\n    while (ch = stream.next()) {\n      if (ch == \"?\" && stream.match(\">\", true)) {\n        state.tokenize = tokenBase;\n        return \"comment meta\";\n      }\n    }\n  }\n\n\n  // functions to test the current context of the state\n  function isInXmlBlock(state) { return isIn(state, \"tag\"); }\n  function isInXmlAttributeBlock(state) { return isIn(state, \"attribute\"); }\n  function isInXmlConstructor(state) { return isIn(state, \"xmlconstructor\"); }\n  function isInString(state) { return isIn(state, \"string\"); }\n\n  function isEQNameAhead(stream) {\n    // assume we've already eaten a quote (\")\n    if(stream.current() === '\"')\n      return stream.match(/^[^\\\"]+\\\"\\:/, false);\n    else if(stream.current() === '\\'')\n      return stream.match(/^[^\\\"]+\\'\\:/, false);\n    else\n      return false;\n  }\n\n  function isIn(state, type) {\n    return (state.stack.length && state.stack[state.stack.length - 1].type == type);\n  }\n\n  function pushStateStack(state, newState) {\n    state.stack.push(newState);\n  }\n\n  function popStateStack(state) {\n    state.stack.pop();\n    var reinstateTokenize = state.stack.length && state.stack[state.stack.length-1].tokenize;\n    state.tokenize = reinstateTokenize || tokenBase;\n  }\n\n  // the interface for the mode API\n  return {\n    startState: function() {\n      return {\n        tokenize: tokenBase,\n        cc: [],\n        stack: []\n      };\n    },\n\n    token: function(stream, state) {\n      if (stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      return style;\n    },\n\n    blockCommentStart: \"(:\",\n    blockCommentEnd: \":)\"\n\n  };\n\n});\n\nCodeMirror.defineMIME(\"application/xquery\", \"xquery\");\n\n});\n"],
  "mappings": "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",
  "names": ["CodeMirror"]
}
