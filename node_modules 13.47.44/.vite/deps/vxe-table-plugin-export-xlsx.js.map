{
  "version": 3,
  "sources": ["../../.pnpm/vxe-table-plugin-export-xlsx@4.0.1_vxe-table@4.6.3_vue@3.4.25_typescript@5.4.5__/node_modules/vxe-table-plugin-export-xlsx/dist/index.ts", "../../.pnpm/vxe-table-plugin-export-xlsx@4.0.1_vxe-table@4.6.3_vue@3.4.25_typescript@5.4.5__/node_modules/vxe-table-plugin-export-xlsx/dist/index.js"],
  "sourcesContent": ["import XEUtils from 'xe-utils'\r\nimport type { VXETableCore, VxeTableConstructor, VxeTablePropTypes, VxeTableDefines, VxeGlobalInterceptorHandles } from 'vxe-table'\r\nimport type ExcelJS from 'exceljs'\r\n\r\nlet globalVxetable: VXETableCore\r\nlet globalExcelJS: any\r\n\r\ndeclare module 'vxe-table' {\r\n  export namespace VxeTableDefines {\r\n    export interface ExtortSheetMethodParams {\r\n      workbook: ExcelJS.Workbook;\r\n      worksheet: ExcelJS.Worksheet;\r\n    }\r\n    export interface ColumnInfo {\r\n      _row: any;\r\n      _colSpan: number;\r\n      _rowSpan: number;\r\n      childNodes: VxeTableDefines.ColumnInfo[];\r\n    }\r\n  }\r\n}\r\n\r\nconst defaultHeaderBackgroundColor = 'f8f8f9'\r\nconst defaultCellFontColor = '606266'\r\nconst defaultCellBorderStyle = 'thin'\r\nconst defaultCellBorderColor = 'e8eaec'\r\n\r\nfunction getCellLabel (column: VxeTableDefines.ColumnInfo, cellValue: any) {\r\n  if (cellValue) {\r\n    if (column.type === 'seq') {\r\n      return XEUtils.toValueString(cellValue)\r\n    }\r\n    switch (column.cellType) {\r\n      case 'string':\r\n        return XEUtils.toValueString(cellValue)\r\n      case 'number':\r\n        if (!isNaN(cellValue)) {\r\n          return Number(cellValue)\r\n        }\r\n        break\r\n      default:\r\n        if (cellValue.length < 12 && !isNaN(cellValue)) {\r\n          return Number(cellValue)\r\n        }\r\n        break\r\n    }\r\n  }\r\n  return cellValue\r\n}\r\n\r\nfunction getFooterData (opts: VxeTablePropTypes.ExportConfig, footerData: any[][]) {\r\n  const { footerFilterMethod } = opts\r\n  return footerFilterMethod ? footerData.filter((items, index) => footerFilterMethod({ items, $rowIndex: index })) : footerData\r\n}\r\n\r\nfunction getFooterCellValue ($table: VxeTableConstructor, opts: VxeTablePropTypes.ExportConfig, rows: any[], column: VxeTableDefines.ColumnInfo) {\r\n  const cellValue = getCellLabel(column, rows[$table.getVMColumnIndex(column)])\r\n  return cellValue\r\n}\r\n\r\nfunction getValidColumn (column: VxeTableDefines.ColumnInfo): VxeTableDefines.ColumnInfo {\r\n  const { childNodes } = column\r\n  const isColGroup = childNodes && childNodes.length\r\n  if (isColGroup) {\r\n    return getValidColumn(childNodes[0])\r\n  }\r\n  return column\r\n}\r\n\r\nfunction setExcelRowHeight (excelRow: ExcelJS.Row, height: number) {\r\n  if (height) {\r\n    excelRow.height = XEUtils.floor(height * 0.75, 12)\r\n  }\r\n}\r\n\r\nfunction setExcelCellStyle (excelCell: ExcelJS.Cell, align?: VxeTablePropTypes.Align | VxeTablePropTypes.HeaderAlign | VxeTablePropTypes.FooterAlign) {\r\n  excelCell.protection = {\r\n    locked: false\r\n  }\r\n  excelCell.alignment = {\r\n    vertical: 'middle',\r\n    horizontal: align || 'left'\r\n  }\r\n}\r\n\r\nfunction getDefaultBorderStyle () {\r\n  return {\r\n    top: {\r\n      style: defaultCellBorderStyle,\r\n      color: {\r\n        argb: defaultCellBorderColor\r\n      }\r\n    },\r\n    left: {\r\n      style: defaultCellBorderStyle,\r\n      color: {\r\n        argb: defaultCellBorderColor\r\n      }\r\n    },\r\n    bottom: {\r\n      style: defaultCellBorderStyle,\r\n      color: {\r\n        argb: defaultCellBorderColor\r\n      }\r\n    },\r\n    right: {\r\n      style: defaultCellBorderStyle,\r\n      color: {\r\n        argb: defaultCellBorderColor\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction exportXLSX (params: VxeGlobalInterceptorHandles.InterceptorExportParams) {\r\n  const msgKey = 'xlsx'\r\n  const { modal, t } = globalVxetable\r\n  const { $table, options, columns, colgroups, datas } = params\r\n  const { props, reactData } = $table\r\n  const { computeColumnOpts } = $table.getComputeMaps()\r\n  const { headerAlign: allHeaderAlign, align: allAlign, footerAlign: allFooterAlign } = props\r\n  const { rowHeight } = reactData\r\n  const { message, sheetName, isHeader, isFooter, isMerge, isColgroup, original, useStyle, sheetMethod } = options\r\n  const columnOpts = computeColumnOpts.value\r\n  const _isCustomColumn: boolean = (options as any)._isCustomColumn\r\n  const showMsg = message !== false\r\n  const mergeCells = $table.getMergeCells()\r\n  const colList: any[] = []\r\n  const footList: any[] = []\r\n  const sheetCols: any[] = []\r\n  const sheetMerges: { s: { r: number, c: number }, e: { r: number, c: number } }[] = []\r\n  let beforeRowCount = 0\r\n  columns.forEach((column) => {\r\n    const { id, renderWidth } = column\r\n    sheetCols.push({\r\n      key: id,\r\n      width: XEUtils.ceil(renderWidth / 8, 1)\r\n    })\r\n  })\r\n  // 处理表头\r\n  if (isHeader) {\r\n    // 处理分组\r\n    if (isColgroup && colgroups) {\r\n      colgroups.forEach((cols, rIndex) => {\r\n        const groupHead: any = {}\r\n        columns.forEach((column) => {\r\n          groupHead[column.id] = null\r\n        })\r\n        cols.forEach((column) => {\r\n          const { _colSpan, _rowSpan } = column\r\n          const validColumn = getValidColumn(column)\r\n          const columnIndex = columns.indexOf(validColumn)\r\n          const headExportMethod = (column as any).headerExportMethod || (columnOpts as any).headerExportMethod\r\n          groupHead[validColumn.id] = headExportMethod ? headExportMethod({ column, options, $table }) : (original ? validColumn.field : column.getTitle())\r\n          if (_colSpan > 1 || _rowSpan > 1) {\r\n            sheetMerges.push({\r\n              s: { r: rIndex, c: columnIndex },\r\n              e: { r: rIndex + _rowSpan - 1, c: columnIndex + _colSpan - 1 }\r\n            })\r\n          }\r\n        })\r\n        colList.push(groupHead)\r\n      })\r\n    } else {\r\n      const colHead: any = {}\r\n      columns.forEach((column) => {\r\n        const { id, field } = column as any\r\n        const headExportMethod = (column as any).headerExportMethod || (columnOpts as any).headerExportMethod\r\n        colHead[id] = headExportMethod ? headExportMethod({ column, options, $table }) : (original ? field : column.getTitle())\r\n      })\r\n      colList.push(colHead)\r\n    }\r\n    beforeRowCount += colList.length\r\n  }\r\n  // 处理合并\r\n  if (isMerge && !_isCustomColumn) {\r\n    mergeCells.forEach(mergeItem => {\r\n      const { row: mergeRowIndex, rowspan: mergeRowspan, col: mergeColIndex, colspan: mergeColspan } = mergeItem\r\n      sheetMerges.push({\r\n        s: { r: mergeRowIndex + beforeRowCount, c: mergeColIndex },\r\n        e: { r: mergeRowIndex + beforeRowCount + mergeRowspan - 1, c: mergeColIndex + mergeColspan - 1 }\r\n      })\r\n    })\r\n  }\r\n  const rowList = datas.map(item => {\r\n    const rest: any = {}\r\n    columns.forEach((column) => {\r\n      rest[column.id] = getCellLabel(column, item[column.id])\r\n    })\r\n    return rest\r\n  })\r\n  beforeRowCount += rowList.length\r\n  // 处理表尾\r\n  if (isFooter) {\r\n    const { footerData } = $table.getTableData()\r\n    const footers = getFooterData(options, footerData)\r\n    const mergeFooterItems = $table.getMergeFooterItems()\r\n    // 处理合并\r\n    if (isMerge && !_isCustomColumn) {\r\n      mergeFooterItems.forEach(mergeItem => {\r\n        const { row: mergeRowIndex, rowspan: mergeRowspan, col: mergeColIndex, colspan: mergeColspan } = mergeItem\r\n        sheetMerges.push({\r\n          s: { r: mergeRowIndex + beforeRowCount, c: mergeColIndex },\r\n          e: { r: mergeRowIndex + beforeRowCount + mergeRowspan - 1, c: mergeColIndex + mergeColspan - 1 }\r\n        })\r\n      })\r\n    }\r\n    footers.forEach((rows) => {\r\n      const item: any = {}\r\n      columns.forEach((column) => {\r\n        item[column.id] = getFooterCellValue($table, options, rows, column)\r\n      })\r\n      footList.push(item)\r\n    })\r\n  }\r\n  const exportMethod = () => {\r\n    const workbook: ExcelJS.Workbook = new (globalExcelJS || (window as any).ExcelJS).Workbook()\r\n    const sheet = workbook.addWorksheet(sheetName)\r\n    workbook.creator = 'vxe-table'\r\n    sheet.columns = sheetCols\r\n    if (isHeader) {\r\n      sheet.addRows(colList).forEach(excelRow => {\r\n        if (useStyle) {\r\n          setExcelRowHeight(excelRow, rowHeight)\r\n        }\r\n        excelRow.eachCell(excelCell => {\r\n          const excelCol = sheet.getColumn(excelCell.col)\r\n          const column: any = $table.getColumnById(excelCol.key as string)\r\n          const { headerAlign, align } = column\r\n          setExcelCellStyle(excelCell, headerAlign || align || allHeaderAlign || allAlign)\r\n          if (useStyle) {\r\n            Object.assign(excelCell, {\r\n              font: {\r\n                bold: true,\r\n                color: {\r\n                  argb: defaultCellFontColor\r\n                }\r\n              },\r\n              fill: {\r\n                type: 'pattern',\r\n                pattern: 'solid',\r\n                fgColor: {\r\n                  argb: defaultHeaderBackgroundColor\r\n                }\r\n              },\r\n              border: getDefaultBorderStyle()\r\n            })\r\n          }\r\n        })\r\n      })\r\n    }\r\n    sheet.addRows(rowList).forEach(excelRow => {\r\n      if (useStyle) {\r\n        setExcelRowHeight(excelRow, rowHeight)\r\n      }\r\n      excelRow.eachCell(excelCell => {\r\n        const excelCol = sheet.getColumn(excelCell.col)\r\n        const column = $table.getColumnById(excelCol.key as string)\r\n        if (column) {\r\n          const { align } = column\r\n          setExcelCellStyle(excelCell, align || allAlign)\r\n          if (useStyle) {\r\n            Object.assign(excelCell, {\r\n              font: {\r\n                color: {\r\n                  argb: defaultCellFontColor\r\n                }\r\n              },\r\n              border: getDefaultBorderStyle()\r\n            })\r\n          }\r\n        }\r\n      })\r\n    })\r\n    if (isFooter) {\r\n      sheet.addRows(footList).forEach(excelRow => {\r\n        if (useStyle) {\r\n          setExcelRowHeight(excelRow, rowHeight)\r\n        }\r\n        excelRow.eachCell(excelCell => {\r\n          const excelCol = sheet.getColumn(excelCell.col)\r\n          const column = $table.getColumnById(excelCol.key as string)\r\n          if (column) {\r\n            const { footerAlign, align } = column\r\n            setExcelCellStyle(excelCell, footerAlign || align || allFooterAlign || allAlign)\r\n            if (useStyle) {\r\n              Object.assign(excelCell, {\r\n                font: {\r\n                  color: {\r\n                    argb: defaultCellFontColor\r\n                  }\r\n                },\r\n                border: getDefaultBorderStyle()\r\n              })\r\n            }\r\n          }\r\n        })\r\n      })\r\n    }\r\n    // 自定义处理\r\n    if (sheetMethod) {\r\n      sheetMethod({ options: options, workbook, worksheet: sheet, columns, colgroups, datas, $table })\r\n    }\r\n    sheetMerges.forEach(({ s, e }) => {\r\n      sheet.mergeCells(s.r + 1, s.c + 1, e.r + 1, e.c + 1)\r\n    })\r\n    workbook.xlsx.writeBuffer().then(buffer => {\r\n      const blob = new Blob([buffer], { type: 'application/octet-stream' })\r\n      // 导出 xlsx\r\n      downloadFile(params, blob, options)\r\n      if (showMsg && modal) {\r\n        modal.close(msgKey)\r\n        modal.message({ content: t('vxe.table.expSuccess'), status: 'success' })\r\n      }\r\n    })\r\n  }\r\n  if (showMsg && modal) {\r\n    modal.message({ id: msgKey, content: t('vxe.table.expLoading'), status: 'loading', duration: -1 })\r\n    setTimeout(exportMethod, 1500)\r\n  } else {\r\n    exportMethod()\r\n  }\r\n}\r\n\r\nfunction downloadFile (params: VxeGlobalInterceptorHandles.InterceptorExportParams, blob: Blob, options: VxeTablePropTypes.ExportConfig) {\r\n  const { modal, t } = globalVxetable\r\n  const { message, filename, type } = options\r\n  const showMsg = message !== false\r\n  if (window.Blob) {\r\n    if ((navigator as any).msSaveBlob) {\r\n      (navigator as any).msSaveBlob(blob, `${filename}.${type}`)\r\n    } else {\r\n      const linkElem = document.createElement('a')\r\n      linkElem.target = '_blank'\r\n      linkElem.download = `${filename}.${type}`\r\n      linkElem.href = URL.createObjectURL(blob)\r\n      document.body.appendChild(linkElem)\r\n      linkElem.click()\r\n      document.body.removeChild(linkElem)\r\n    }\r\n  } else {\r\n    if (showMsg && modal) {\r\n      modal.alert({ content: t('vxe.error.notExp'), status: 'error' })\r\n    }\r\n  }\r\n}\r\n\r\nfunction checkImportData (tableFields: string[], fields: string[]) {\r\n  return fields.some(field => tableFields.indexOf(field) > -1)\r\n}\r\n\r\nfunction importError (params: VxeGlobalInterceptorHandles.InterceptorImportParams) {\r\n  const { modal, t } = globalVxetable\r\n  const { $table, options } = params\r\n  const { internalData } = $table\r\n  const { _importReject } = internalData\r\n  const showMsg = options.message !== false\r\n  if (showMsg && modal) {\r\n    modal.message({ content: t('vxe.error.impFields'), status: 'error' })\r\n  }\r\n  if (_importReject) {\r\n    _importReject({ status: false })\r\n  }\r\n}\r\n\r\nfunction importXLSX (params: VxeGlobalInterceptorHandles.InterceptorImportParams) {\r\n  const { modal, t } = globalVxetable\r\n  const { $table, columns, options, file } = params\r\n  const { internalData } = $table\r\n  const { _importResolve } = internalData\r\n  const showMsg = options.message !== false\r\n  const fileReader = new FileReader()\r\n  fileReader.onerror = () => {\r\n    importError(params)\r\n  }\r\n  fileReader.onload = (evnt) => {\r\n    const tableFields: string[] = []\r\n    columns.forEach((column) => {\r\n      const field = column.field\r\n      if (field) {\r\n        tableFields.push(field)\r\n      }\r\n    })\r\n    const workbook: ExcelJS.Workbook = new (globalExcelJS || (window as any).ExcelJS).Workbook()\r\n    const readerTarget = evnt.target\r\n    if (readerTarget) {\r\n      workbook.xlsx.load(readerTarget.result as ArrayBuffer).then(wb => {\r\n        const firstSheet = wb.worksheets[0]\r\n        if (firstSheet) {\r\n          const sheetValues = firstSheet.getSheetValues() as string[][]\r\n          const fieldIndex = XEUtils.findIndexOf(sheetValues, (list) => list && list.length > 0)\r\n          const fields = sheetValues[fieldIndex] as string[]\r\n          const status = checkImportData(tableFields, fields)\r\n          if (status) {\r\n            const records = sheetValues.slice(fieldIndex).map(list => {\r\n              const item : any = {}\r\n              list.forEach((cellValue, cIndex) => {\r\n                item[fields[cIndex]] = cellValue\r\n              })\r\n              const record: any = {}\r\n              tableFields.forEach(field => {\r\n                record[field] = XEUtils.isUndefined(item[field]) ? null : item[field]\r\n              })\r\n              return record\r\n            })\r\n            $table.createData(records)\r\n              .then((data: any[]) => {\r\n                let loadRest: Promise<any>\r\n                if (options.mode === 'insert') {\r\n                  loadRest = $table.insertAt(data, -1)\r\n                } else {\r\n                  loadRest = $table.reloadData(data)\r\n                }\r\n                return loadRest.then(() => {\r\n                  if (_importResolve) {\r\n                    _importResolve({ status: true })\r\n                  }\r\n                })\r\n              })\r\n            if (showMsg && modal) {\r\n              modal.message({ content: t('vxe.table.impSuccess', [records.length]), status: 'success' })\r\n            }\r\n          } else {\r\n            importError(params)\r\n          }\r\n        } else {\r\n          importError(params)\r\n        }\r\n      })\r\n    } else {\r\n      importError(params)\r\n    }\r\n  }\r\n  fileReader.readAsArrayBuffer(file)\r\n}\r\n\r\nfunction handleImportEvent (params: VxeGlobalInterceptorHandles.InterceptorImportParams) {\r\n  if (params.options.type === 'xlsx') {\r\n    importXLSX(params)\r\n    return false\r\n  }\r\n}\r\n\r\nfunction handleExportEvent (params: VxeGlobalInterceptorHandles.InterceptorExportParams) {\r\n  if (params.options.type === 'xlsx') {\r\n    exportXLSX(params)\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * 基于 vxe-table 表格的扩展插件，支持导出 xlsx 格式\r\n */\r\nexport const VXETablePluginExportXLSX = {\r\n  install (vxetable: VXETableCore, options?: {\r\n    ExcelJS?: any\r\n  }) {\r\n    // 检查版本\r\n    if (!/^(4)\\./.test(vxetable.version)) {\r\n      console.error('[vxe-table-plugin-export-pdf] Version vxe-table 4.x is required')\r\n    }\r\n\r\n    globalVxetable = vxetable\r\n    globalExcelJS = options ? options.ExcelJS : null\r\n\r\n    vxetable.config({\r\n      export: {\r\n        types: {\r\n          xlsx: 0\r\n        }\r\n      }\r\n    })\r\n    vxetable.interceptor.mixin({\r\n      'event.import': handleImportEvent,\r\n      'event.export': handleExportEvent\r\n    })\r\n  }\r\n}\r\n\r\nif (typeof window !== 'undefined' && window.VXETable && window.VXETable.use) {\r\n  window.VXETable.use(VXETablePluginExportXLSX)\r\n}\r\n\r\nexport default VXETablePluginExportXLSX\r\n", "import XEUtils from 'xe-utils';\nlet globalVxetable;\nlet globalExcelJS;\nconst defaultHeaderBackgroundColor = 'f8f8f9';\nconst defaultCellFontColor = '606266';\nconst defaultCellBorderStyle = 'thin';\nconst defaultCellBorderColor = 'e8eaec';\nfunction getCellLabel(column, cellValue) {\n    if (cellValue) {\n        if (column.type === 'seq') {\n            return XEUtils.toValueString(cellValue);\n        }\n        switch (column.cellType) {\n            case 'string':\n                return XEUtils.toValueString(cellValue);\n            case 'number':\n                if (!isNaN(cellValue)) {\n                    return Number(cellValue);\n                }\n                break;\n            default:\n                if (cellValue.length < 12 && !isNaN(cellValue)) {\n                    return Number(cellValue);\n                }\n                break;\n        }\n    }\n    return cellValue;\n}\nfunction getFooterData(opts, footerData) {\n    const { footerFilterMethod } = opts;\n    return footerFilterMethod ? footerData.filter((items, index) => footerFilterMethod({ items, $rowIndex: index })) : footerData;\n}\nfunction getFooterCellValue($table, opts, rows, column) {\n    const cellValue = getCellLabel(column, rows[$table.getVMColumnIndex(column)]);\n    return cellValue;\n}\nfunction getValidColumn(column) {\n    const { childNodes } = column;\n    const isColGroup = childNodes && childNodes.length;\n    if (isColGroup) {\n        return getValidColumn(childNodes[0]);\n    }\n    return column;\n}\nfunction setExcelRowHeight(excelRow, height) {\n    if (height) {\n        excelRow.height = XEUtils.floor(height * 0.75, 12);\n    }\n}\nfunction setExcelCellStyle(excelCell, align) {\n    excelCell.protection = {\n        locked: false\n    };\n    excelCell.alignment = {\n        vertical: 'middle',\n        horizontal: align || 'left'\n    };\n}\nfunction getDefaultBorderStyle() {\n    return {\n        top: {\n            style: defaultCellBorderStyle,\n            color: {\n                argb: defaultCellBorderColor\n            }\n        },\n        left: {\n            style: defaultCellBorderStyle,\n            color: {\n                argb: defaultCellBorderColor\n            }\n        },\n        bottom: {\n            style: defaultCellBorderStyle,\n            color: {\n                argb: defaultCellBorderColor\n            }\n        },\n        right: {\n            style: defaultCellBorderStyle,\n            color: {\n                argb: defaultCellBorderColor\n            }\n        }\n    };\n}\nfunction exportXLSX(params) {\n    const msgKey = 'xlsx';\n    const { modal, t } = globalVxetable;\n    const { $table, options, columns, colgroups, datas } = params;\n    const { props, reactData } = $table;\n    const { computeColumnOpts } = $table.getComputeMaps();\n    const { headerAlign: allHeaderAlign, align: allAlign, footerAlign: allFooterAlign } = props;\n    const { rowHeight } = reactData;\n    const { message, sheetName, isHeader, isFooter, isMerge, isColgroup, original, useStyle, sheetMethod } = options;\n    const columnOpts = computeColumnOpts.value;\n    const _isCustomColumn = options._isCustomColumn;\n    const showMsg = message !== false;\n    const mergeCells = $table.getMergeCells();\n    const colList = [];\n    const footList = [];\n    const sheetCols = [];\n    const sheetMerges = [];\n    let beforeRowCount = 0;\n    columns.forEach((column) => {\n        const { id, renderWidth } = column;\n        sheetCols.push({\n            key: id,\n            width: XEUtils.ceil(renderWidth / 8, 1)\n        });\n    });\n    // 处理表头\n    if (isHeader) {\n        // 处理分组\n        if (isColgroup && colgroups) {\n            colgroups.forEach((cols, rIndex) => {\n                const groupHead = {};\n                columns.forEach((column) => {\n                    groupHead[column.id] = null;\n                });\n                cols.forEach((column) => {\n                    const { _colSpan, _rowSpan } = column;\n                    const validColumn = getValidColumn(column);\n                    const columnIndex = columns.indexOf(validColumn);\n                    const headExportMethod = column.headerExportMethod || columnOpts.headerExportMethod;\n                    groupHead[validColumn.id] = headExportMethod ? headExportMethod({ column, options, $table }) : (original ? validColumn.field : column.getTitle());\n                    if (_colSpan > 1 || _rowSpan > 1) {\n                        sheetMerges.push({\n                            s: { r: rIndex, c: columnIndex },\n                            e: { r: rIndex + _rowSpan - 1, c: columnIndex + _colSpan - 1 }\n                        });\n                    }\n                });\n                colList.push(groupHead);\n            });\n        }\n        else {\n            const colHead = {};\n            columns.forEach((column) => {\n                const { id, field } = column;\n                const headExportMethod = column.headerExportMethod || columnOpts.headerExportMethod;\n                colHead[id] = headExportMethod ? headExportMethod({ column, options, $table }) : (original ? field : column.getTitle());\n            });\n            colList.push(colHead);\n        }\n        beforeRowCount += colList.length;\n    }\n    // 处理合并\n    if (isMerge && !_isCustomColumn) {\n        mergeCells.forEach(mergeItem => {\n            const { row: mergeRowIndex, rowspan: mergeRowspan, col: mergeColIndex, colspan: mergeColspan } = mergeItem;\n            sheetMerges.push({\n                s: { r: mergeRowIndex + beforeRowCount, c: mergeColIndex },\n                e: { r: mergeRowIndex + beforeRowCount + mergeRowspan - 1, c: mergeColIndex + mergeColspan - 1 }\n            });\n        });\n    }\n    const rowList = datas.map(item => {\n        const rest = {};\n        columns.forEach((column) => {\n            rest[column.id] = getCellLabel(column, item[column.id]);\n        });\n        return rest;\n    });\n    beforeRowCount += rowList.length;\n    // 处理表尾\n    if (isFooter) {\n        const { footerData } = $table.getTableData();\n        const footers = getFooterData(options, footerData);\n        const mergeFooterItems = $table.getMergeFooterItems();\n        // 处理合并\n        if (isMerge && !_isCustomColumn) {\n            mergeFooterItems.forEach(mergeItem => {\n                const { row: mergeRowIndex, rowspan: mergeRowspan, col: mergeColIndex, colspan: mergeColspan } = mergeItem;\n                sheetMerges.push({\n                    s: { r: mergeRowIndex + beforeRowCount, c: mergeColIndex },\n                    e: { r: mergeRowIndex + beforeRowCount + mergeRowspan - 1, c: mergeColIndex + mergeColspan - 1 }\n                });\n            });\n        }\n        footers.forEach((rows) => {\n            const item = {};\n            columns.forEach((column) => {\n                item[column.id] = getFooterCellValue($table, options, rows, column);\n            });\n            footList.push(item);\n        });\n    }\n    const exportMethod = () => {\n        const workbook = new (globalExcelJS || window.ExcelJS).Workbook();\n        const sheet = workbook.addWorksheet(sheetName);\n        workbook.creator = 'vxe-table';\n        sheet.columns = sheetCols;\n        if (isHeader) {\n            sheet.addRows(colList).forEach(excelRow => {\n                if (useStyle) {\n                    setExcelRowHeight(excelRow, rowHeight);\n                }\n                excelRow.eachCell(excelCell => {\n                    const excelCol = sheet.getColumn(excelCell.col);\n                    const column = $table.getColumnById(excelCol.key);\n                    const { headerAlign, align } = column;\n                    setExcelCellStyle(excelCell, headerAlign || align || allHeaderAlign || allAlign);\n                    if (useStyle) {\n                        Object.assign(excelCell, {\n                            font: {\n                                bold: true,\n                                color: {\n                                    argb: defaultCellFontColor\n                                }\n                            },\n                            fill: {\n                                type: 'pattern',\n                                pattern: 'solid',\n                                fgColor: {\n                                    argb: defaultHeaderBackgroundColor\n                                }\n                            },\n                            border: getDefaultBorderStyle()\n                        });\n                    }\n                });\n            });\n        }\n        sheet.addRows(rowList).forEach(excelRow => {\n            if (useStyle) {\n                setExcelRowHeight(excelRow, rowHeight);\n            }\n            excelRow.eachCell(excelCell => {\n                const excelCol = sheet.getColumn(excelCell.col);\n                const column = $table.getColumnById(excelCol.key);\n                if (column) {\n                    const { align } = column;\n                    setExcelCellStyle(excelCell, align || allAlign);\n                    if (useStyle) {\n                        Object.assign(excelCell, {\n                            font: {\n                                color: {\n                                    argb: defaultCellFontColor\n                                }\n                            },\n                            border: getDefaultBorderStyle()\n                        });\n                    }\n                }\n            });\n        });\n        if (isFooter) {\n            sheet.addRows(footList).forEach(excelRow => {\n                if (useStyle) {\n                    setExcelRowHeight(excelRow, rowHeight);\n                }\n                excelRow.eachCell(excelCell => {\n                    const excelCol = sheet.getColumn(excelCell.col);\n                    const column = $table.getColumnById(excelCol.key);\n                    if (column) {\n                        const { footerAlign, align } = column;\n                        setExcelCellStyle(excelCell, footerAlign || align || allFooterAlign || allAlign);\n                        if (useStyle) {\n                            Object.assign(excelCell, {\n                                font: {\n                                    color: {\n                                        argb: defaultCellFontColor\n                                    }\n                                },\n                                border: getDefaultBorderStyle()\n                            });\n                        }\n                    }\n                });\n            });\n        }\n        // 自定义处理\n        if (sheetMethod) {\n            sheetMethod({ options: options, workbook, worksheet: sheet, columns, colgroups, datas, $table });\n        }\n        sheetMerges.forEach(({ s, e }) => {\n            sheet.mergeCells(s.r + 1, s.c + 1, e.r + 1, e.c + 1);\n        });\n        workbook.xlsx.writeBuffer().then(buffer => {\n            const blob = new Blob([buffer], { type: 'application/octet-stream' });\n            // 导出 xlsx\n            downloadFile(params, blob, options);\n            if (showMsg && modal) {\n                modal.close(msgKey);\n                modal.message({ content: t('vxe.table.expSuccess'), status: 'success' });\n            }\n        });\n    };\n    if (showMsg && modal) {\n        modal.message({ id: msgKey, content: t('vxe.table.expLoading'), status: 'loading', duration: -1 });\n        setTimeout(exportMethod, 1500);\n    }\n    else {\n        exportMethod();\n    }\n}\nfunction downloadFile(params, blob, options) {\n    const { modal, t } = globalVxetable;\n    const { message, filename, type } = options;\n    const showMsg = message !== false;\n    if (window.Blob) {\n        if (navigator.msSaveBlob) {\n            navigator.msSaveBlob(blob, `${filename}.${type}`);\n        }\n        else {\n            const linkElem = document.createElement('a');\n            linkElem.target = '_blank';\n            linkElem.download = `${filename}.${type}`;\n            linkElem.href = URL.createObjectURL(blob);\n            document.body.appendChild(linkElem);\n            linkElem.click();\n            document.body.removeChild(linkElem);\n        }\n    }\n    else {\n        if (showMsg && modal) {\n            modal.alert({ content: t('vxe.error.notExp'), status: 'error' });\n        }\n    }\n}\nfunction checkImportData(tableFields, fields) {\n    return fields.some(field => tableFields.indexOf(field) > -1);\n}\nfunction importError(params) {\n    const { modal, t } = globalVxetable;\n    const { $table, options } = params;\n    const { internalData } = $table;\n    const { _importReject } = internalData;\n    const showMsg = options.message !== false;\n    if (showMsg && modal) {\n        modal.message({ content: t('vxe.error.impFields'), status: 'error' });\n    }\n    if (_importReject) {\n        _importReject({ status: false });\n    }\n}\nfunction importXLSX(params) {\n    const { modal, t } = globalVxetable;\n    const { $table, columns, options, file } = params;\n    const { internalData } = $table;\n    const { _importResolve } = internalData;\n    const showMsg = options.message !== false;\n    const fileReader = new FileReader();\n    fileReader.onerror = () => {\n        importError(params);\n    };\n    fileReader.onload = (evnt) => {\n        const tableFields = [];\n        columns.forEach((column) => {\n            const field = column.field;\n            if (field) {\n                tableFields.push(field);\n            }\n        });\n        const workbook = new (globalExcelJS || window.ExcelJS).Workbook();\n        const readerTarget = evnt.target;\n        if (readerTarget) {\n            workbook.xlsx.load(readerTarget.result).then(wb => {\n                const firstSheet = wb.worksheets[0];\n                if (firstSheet) {\n                    const sheetValues = firstSheet.getSheetValues();\n                    const fieldIndex = XEUtils.findIndexOf(sheetValues, (list) => list && list.length > 0);\n                    const fields = sheetValues[fieldIndex];\n                    const status = checkImportData(tableFields, fields);\n                    if (status) {\n                        const records = sheetValues.slice(fieldIndex).map(list => {\n                            const item = {};\n                            list.forEach((cellValue, cIndex) => {\n                                item[fields[cIndex]] = cellValue;\n                            });\n                            const record = {};\n                            tableFields.forEach(field => {\n                                record[field] = XEUtils.isUndefined(item[field]) ? null : item[field];\n                            });\n                            return record;\n                        });\n                        $table.createData(records)\n                            .then((data) => {\n                            let loadRest;\n                            if (options.mode === 'insert') {\n                                loadRest = $table.insertAt(data, -1);\n                            }\n                            else {\n                                loadRest = $table.reloadData(data);\n                            }\n                            return loadRest.then(() => {\n                                if (_importResolve) {\n                                    _importResolve({ status: true });\n                                }\n                            });\n                        });\n                        if (showMsg && modal) {\n                            modal.message({ content: t('vxe.table.impSuccess', [records.length]), status: 'success' });\n                        }\n                    }\n                    else {\n                        importError(params);\n                    }\n                }\n                else {\n                    importError(params);\n                }\n            });\n        }\n        else {\n            importError(params);\n        }\n    };\n    fileReader.readAsArrayBuffer(file);\n}\nfunction handleImportEvent(params) {\n    if (params.options.type === 'xlsx') {\n        importXLSX(params);\n        return false;\n    }\n}\nfunction handleExportEvent(params) {\n    if (params.options.type === 'xlsx') {\n        exportXLSX(params);\n        return false;\n    }\n}\n/**\n * 基于 vxe-table 表格的扩展插件，支持导出 xlsx 格式\n */\nexport const VXETablePluginExportXLSX = {\n    install(vxetable, options) {\n        // 检查版本\n        if (!/^(4)\\./.test(vxetable.version)) {\n            console.error('[vxe-table-plugin-export-pdf] Version vxe-table 4.x is required');\n        }\n        globalVxetable = vxetable;\n        globalExcelJS = options ? options.ExcelJS : null;\n        vxetable.config({\n            export: {\n                types: {\n                    xlsx: 0\n                }\n            }\n        });\n        vxetable.interceptor.mixin({\n            'event.import': handleImportEvent,\n            'event.export': handleExportEvent\n        });\n    }\n};\nif (typeof window !== 'undefined' && window.VXETable && window.VXETable.use) {\n    window.VXETable.use(VXETablePluginExportXLSX);\n}\nexport default VXETablePluginExportXLSX;\n"],
  "mappings": "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",
  "names": ["globalVxetable", "globalExcelJS", "defaultHeaderBackgroundColor", "defaultCellFontColor", "defaultCellBorderStyle", "defaultCellBorderColor", "getCellLabel", "column", "cellValue", "type", "XEUtils", "toValueString", "cellType", "isNaN", "Number", "length", "getFooterData", "opts", "footerData", "footerFilterMethod", "filter", "items", "index", "$rowIndex", "getFooterCellValue", "$table", "rows", "getVMColumnIndex", "getValidColumn", "childNodes", "isColGroup", "setExcelRowHeight", "excelRow", "height", "floor", "setExcelCellStyle", "excelCell", "align", "protection", "locked", "alignment", "vertical", "horizontal", "getDefaultBorderStyle", "top", "style", "color", "argb", "left", "bottom", "right", "exportXLSX", "params", "msgKey", "modal", "t", "options", "columns", "colgroups", "datas", "props", "reactData", "getComputeMaps", "computeColumnOpts", "allHeaderAlign", "headerAlign", "allAlign", "allFooterAlign", "footerAlign", "rowHeight", "message", "sheetName", "isHeader", "isFooter", "isMerge", "isColgroup", "original", "useStyle", "sheetMethod", "columnOpts", "value", "_isCustomColumn", "showMsg", "mergeCells", "getMergeCells", "colList", "footList", "sheetCols", "sheetMerges", "beforeRowCount", "forEach", "id", "renderWidth", "push", "key", "width", "ceil", "cols", "rIndex", "groupHead", "_colSpan", "_rowSpan", "validColumn", "columnIndex", "indexOf", "headExportMethod", "headerExportMethod", "field", "getTitle", "s", "r", "c", "e", "colHead", "mergeItem", "mergeRowIndex", "row", "mergeRowspan", "rowspan", "mergeColIndex", "col", "mergeColspan", "colspan", "rowList", "map", "item", "rest", "getTableData", "footers", "mergeFooterItems", "getMergeFooterItems", "exportMethod", "workbook", "window", "ExcelJS", "Workbook", "sheet", "addWorksheet", "creator", "addRows", "eachCell", "excelCol", "getColumn", "getColumnById", "Object", "assign", "font", "bold", "fill", "pattern", "fgColor", "border", "worksheet", "xlsx", "writeBuffer", "then", "buffer", "blob", "Blob", "downloadFile", "close", "content", "status", "duration", "setTimeout", "filename", "navigator", "msSaveBlob", "linkElem", "document", "createElement", "target", "download", "href", "URL", "createObjectURL", "body", "appendChild", "click", "removeChild", "alert", "checkImportData", "tableFields", "fields", "some", "importError", "internalData", "_importReject", "importXLSX", "file", "_importResolve", "fileReader", "FileReader", "onerror", "onload", "evnt", "readerTarget", "load", "result", "wb", "firstSheet", "worksheets", "sheetValues", "getSheetValues", "fieldIndex", "findIndexOf", "list", "records", "slice", "cIndex", "record", "isUndefined", "createData", "data", "loadRest", "mode", "insertAt", "reloadData", "readAsArrayBuffer", "handleImportEvent", "handleExportEvent", "VXETablePluginExportXLSX", "install", "vxetable", "test", "version", "console", "error", "config", "types", "interceptor", "mixin", "VXETable", "use"]
}
