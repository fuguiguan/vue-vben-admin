{
  "version": 3,
  "sources": ["../../.pnpm/codemirror@5.65.16/node_modules/codemirror/mode/sass/sass.js"],
  "sourcesContent": ["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../css/css\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../css/css\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"sass\", function(config) {\n  var cssMode = CodeMirror.mimeModes[\"text/css\"];\n  var propertyKeywords = cssMode.propertyKeywords || {},\n      colorKeywords = cssMode.colorKeywords || {},\n      valueKeywords = cssMode.valueKeywords || {},\n      fontProperties = cssMode.fontProperties || {};\n\n  function tokenRegexp(words) {\n    return new RegExp(\"^\" + words.join(\"|\"));\n  }\n\n  var keywords = [\"true\", \"false\", \"null\", \"auto\"];\n  var keywordsRegexp = new RegExp(\"^\" + keywords.join(\"|\"));\n\n  var operators = [\"\\\\(\", \"\\\\)\", \"=\", \">\", \"<\", \"==\", \">=\", \"<=\", \"\\\\+\", \"-\",\n                   \"\\\\!=\", \"/\", \"\\\\*\", \"%\", \"and\", \"or\", \"not\", \";\",\"\\\\{\",\"\\\\}\",\":\"];\n  var opRegexp = tokenRegexp(operators);\n\n  var pseudoElementsRegexp = /^::?[a-zA-Z_][\\w\\-]*/;\n\n  var word;\n\n  function isEndLine(stream) {\n    return !stream.peek() || stream.match(/\\s+$/, false);\n  }\n\n  function urlTokens(stream, state) {\n    var ch = stream.peek();\n\n    if (ch === \")\") {\n      stream.next();\n      state.tokenizer = tokenBase;\n      return \"operator\";\n    } else if (ch === \"(\") {\n      stream.next();\n      stream.eatSpace();\n\n      return \"operator\";\n    } else if (ch === \"'\" || ch === '\"') {\n      state.tokenizer = buildStringTokenizer(stream.next());\n      return \"string\";\n    } else {\n      state.tokenizer = buildStringTokenizer(\")\", false);\n      return \"string\";\n    }\n  }\n  function comment(indentation, multiLine) {\n    return function(stream, state) {\n      if (stream.sol() && stream.indentation() <= indentation) {\n        state.tokenizer = tokenBase;\n        return tokenBase(stream, state);\n      }\n\n      if (multiLine && stream.skipTo(\"*/\")) {\n        stream.next();\n        stream.next();\n        state.tokenizer = tokenBase;\n      } else {\n        stream.skipToEnd();\n      }\n\n      return \"comment\";\n    };\n  }\n\n  function buildStringTokenizer(quote, greedy) {\n    if (greedy == null) { greedy = true; }\n\n    function stringTokenizer(stream, state) {\n      var nextChar = stream.next();\n      var peekChar = stream.peek();\n      var previousChar = stream.string.charAt(stream.pos-2);\n\n      var endingString = ((nextChar !== \"\\\\\" && peekChar === quote) || (nextChar === quote && previousChar !== \"\\\\\"));\n\n      if (endingString) {\n        if (nextChar !== quote && greedy) { stream.next(); }\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        state.tokenizer = tokenBase;\n        return \"string\";\n      } else if (nextChar === \"#\" && peekChar === \"{\") {\n        state.tokenizer = buildInterpolationTokenizer(stringTokenizer);\n        stream.next();\n        return \"operator\";\n      } else {\n        return \"string\";\n      }\n    }\n\n    return stringTokenizer;\n  }\n\n  function buildInterpolationTokenizer(currentTokenizer) {\n    return function(stream, state) {\n      if (stream.peek() === \"}\") {\n        stream.next();\n        state.tokenizer = currentTokenizer;\n        return \"operator\";\n      } else {\n        return tokenBase(stream, state);\n      }\n    };\n  }\n\n  function indent(state) {\n    if (state.indentCount == 0) {\n      state.indentCount++;\n      var lastScopeOffset = state.scopes[0].offset;\n      var currentOffset = lastScopeOffset + config.indentUnit;\n      state.scopes.unshift({ offset:currentOffset });\n    }\n  }\n\n  function dedent(state) {\n    if (state.scopes.length == 1) return;\n\n    state.scopes.shift();\n  }\n\n  function tokenBase(stream, state) {\n    var ch = stream.peek();\n\n    // Comment\n    if (stream.match(\"/*\")) {\n      state.tokenizer = comment(stream.indentation(), true);\n      return state.tokenizer(stream, state);\n    }\n    if (stream.match(\"//\")) {\n      state.tokenizer = comment(stream.indentation(), false);\n      return state.tokenizer(stream, state);\n    }\n\n    // Interpolation\n    if (stream.match(\"#{\")) {\n      state.tokenizer = buildInterpolationTokenizer(tokenBase);\n      return \"operator\";\n    }\n\n    // Strings\n    if (ch === '\"' || ch === \"'\") {\n      stream.next();\n      state.tokenizer = buildStringTokenizer(ch);\n      return \"string\";\n    }\n\n    if(!state.cursorHalf){// state.cursorHalf === 0\n    // first half i.e. before : for key-value pairs\n    // including selectors\n\n      if (ch === \"-\") {\n        if (stream.match(/^-\\w+-/)) {\n          return \"meta\";\n        }\n      }\n\n      if (ch === \".\") {\n        stream.next();\n        if (stream.match(/^[\\w-]+/)) {\n          indent(state);\n          return \"qualifier\";\n        } else if (stream.peek() === \"#\") {\n          indent(state);\n          return \"tag\";\n        }\n      }\n\n      if (ch === \"#\") {\n        stream.next();\n        // ID selectors\n        if (stream.match(/^[\\w-]+/)) {\n          indent(state);\n          return \"builtin\";\n        }\n        if (stream.peek() === \"#\") {\n          indent(state);\n          return \"tag\";\n        }\n      }\n\n      // Variables\n      if (ch === \"$\") {\n        stream.next();\n        stream.eatWhile(/[\\w-]/);\n        return \"variable-2\";\n      }\n\n      // Numbers\n      if (stream.match(/^-?[0-9\\.]+/))\n        return \"number\";\n\n      // Units\n      if (stream.match(/^(px|em|in)\\b/))\n        return \"unit\";\n\n      if (stream.match(keywordsRegexp))\n        return \"keyword\";\n\n      if (stream.match(/^url/) && stream.peek() === \"(\") {\n        state.tokenizer = urlTokens;\n        return \"atom\";\n      }\n\n      if (ch === \"=\") {\n        // Match shortcut mixin definition\n        if (stream.match(/^=[\\w-]+/)) {\n          indent(state);\n          return \"meta\";\n        }\n      }\n\n      if (ch === \"+\") {\n        // Match shortcut mixin definition\n        if (stream.match(/^\\+[\\w-]+/)){\n          return \"variable-3\";\n        }\n      }\n\n      if(ch === \"@\"){\n        if(stream.match('@extend')){\n          if(!stream.match(/\\s*[\\w]/))\n            dedent(state);\n        }\n      }\n\n\n      // Indent Directives\n      if (stream.match(/^@(else if|if|media|else|for|each|while|mixin|function)/)) {\n        indent(state);\n        return \"def\";\n      }\n\n      // Other Directives\n      if (ch === \"@\") {\n        stream.next();\n        stream.eatWhile(/[\\w-]/);\n        return \"def\";\n      }\n\n      if (stream.eatWhile(/[\\w-]/)){\n        if(stream.match(/ *: *[\\w-\\+\\$#!\\(\"']/,false)){\n          word = stream.current().toLowerCase();\n          var prop = state.prevProp + \"-\" + word;\n          if (propertyKeywords.hasOwnProperty(prop)) {\n            return \"property\";\n          } else if (propertyKeywords.hasOwnProperty(word)) {\n            state.prevProp = word;\n            return \"property\";\n          } else if (fontProperties.hasOwnProperty(word)) {\n            return \"property\";\n          }\n          return \"tag\";\n        }\n        else if(stream.match(/ *:/,false)){\n          indent(state);\n          state.cursorHalf = 1;\n          state.prevProp = stream.current().toLowerCase();\n          return \"property\";\n        }\n        else if(stream.match(/ *,/,false)){\n          return \"tag\";\n        }\n        else{\n          indent(state);\n          return \"tag\";\n        }\n      }\n\n      if(ch === \":\"){\n        if (stream.match(pseudoElementsRegexp)){ // could be a pseudo-element\n          return \"variable-3\";\n        }\n        stream.next();\n        state.cursorHalf=1;\n        return \"operator\";\n      }\n\n    } // cursorHalf===0 ends here\n    else{\n\n      if (ch === \"#\") {\n        stream.next();\n        // Hex numbers\n        if (stream.match(/[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/)){\n          if (isEndLine(stream)) {\n            state.cursorHalf = 0;\n          }\n          return \"number\";\n        }\n      }\n\n      // Numbers\n      if (stream.match(/^-?[0-9\\.]+/)){\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"number\";\n      }\n\n      // Units\n      if (stream.match(/^(px|em|in)\\b/)){\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"unit\";\n      }\n\n      if (stream.match(keywordsRegexp)){\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"keyword\";\n      }\n\n      if (stream.match(/^url/) && stream.peek() === \"(\") {\n        state.tokenizer = urlTokens;\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"atom\";\n      }\n\n      // Variables\n      if (ch === \"$\") {\n        stream.next();\n        stream.eatWhile(/[\\w-]/);\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"variable-2\";\n      }\n\n      // bang character for !important, !default, etc.\n      if (ch === \"!\") {\n        stream.next();\n        state.cursorHalf = 0;\n        return stream.match(/^[\\w]+/) ? \"keyword\": \"operator\";\n      }\n\n      if (stream.match(opRegexp)){\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"operator\";\n      }\n\n      // attributes\n      if (stream.eatWhile(/[\\w-]/)) {\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        word = stream.current().toLowerCase();\n        if (valueKeywords.hasOwnProperty(word)) {\n          return \"atom\";\n        } else if (colorKeywords.hasOwnProperty(word)) {\n          return \"keyword\";\n        } else if (propertyKeywords.hasOwnProperty(word)) {\n          state.prevProp = stream.current().toLowerCase();\n          return \"property\";\n        } else {\n          return \"tag\";\n        }\n      }\n\n      //stream.eatSpace();\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0;\n        return null;\n      }\n\n    } // else ends here\n\n    if (stream.match(opRegexp))\n      return \"operator\";\n\n    // If we haven't returned by now, we move 1 character\n    // and return an error\n    stream.next();\n    return null;\n  }\n\n  function tokenLexer(stream, state) {\n    if (stream.sol()) state.indentCount = 0;\n    var style = state.tokenizer(stream, state);\n    var current = stream.current();\n\n    if (current === \"@return\" || current === \"}\"){\n      dedent(state);\n    }\n\n    if (style !== null) {\n      var startOfToken = stream.pos - current.length;\n\n      var withCurrentIndent = startOfToken + (config.indentUnit * state.indentCount);\n\n      var newScopes = [];\n\n      for (var i = 0; i < state.scopes.length; i++) {\n        var scope = state.scopes[i];\n\n        if (scope.offset <= withCurrentIndent)\n          newScopes.push(scope);\n      }\n\n      state.scopes = newScopes;\n    }\n\n\n    return style;\n  }\n\n  return {\n    startState: function() {\n      return {\n        tokenizer: tokenBase,\n        scopes: [{offset: 0, type: \"sass\"}],\n        indentCount: 0,\n        cursorHalf: 0,  // cursor half tells us if cursor lies after (1)\n                        // or before (0) colon (well... more or less)\n        definedVars: [],\n        definedMixins: []\n      };\n    },\n    token: function(stream, state) {\n      var style = tokenLexer(stream, state);\n\n      state.lastToken = { style: style, content: stream.current() };\n\n      return style;\n    },\n\n    indent: function(state) {\n      return state.scopes[0].offset;\n    },\n\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\",\n    lineComment: \"//\",\n    fold: \"indent\"\n  };\n}, \"css\");\n\nCodeMirror.defineMIME(\"text/x-sass\", \"sass\");\n\n});\n"],
  "mappings": "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",
  "names": ["CodeMirror"]
}
