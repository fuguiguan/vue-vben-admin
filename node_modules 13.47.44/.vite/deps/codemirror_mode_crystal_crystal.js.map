{
  "version": 3,
  "sources": ["../../.pnpm/codemirror@5.65.16/node_modules/codemirror/mode/crystal/crystal.js"],
  "sourcesContent": ["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"crystal\", function(config) {\n    function wordRegExp(words, end) {\n      return new RegExp((end ? \"\" : \"^\") + \"(?:\" + words.join(\"|\") + \")\" + (end ? \"$\" : \"\\\\b\"));\n    }\n\n    function chain(tokenize, stream, state) {\n      state.tokenize.push(tokenize);\n      return tokenize(stream, state);\n    }\n\n    var operators = /^(?:[-+/%|&^]|\\*\\*?|[<>]{2})/;\n    var conditionalOperators = /^(?:[=!]~|===|<=>|[<>=!]=?|[|&]{2}|~)/;\n    var indexingOperators = /^(?:\\[\\][?=]?)/;\n    var anotherOperators = /^(?:\\.(?:\\.{2})?|->|[?:])/;\n    var idents = /^[a-z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\n    var types = /^[A-Z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\n    var keywords = wordRegExp([\n      \"abstract\", \"alias\", \"as\", \"asm\", \"begin\", \"break\", \"case\", \"class\", \"def\", \"do\",\n      \"else\", \"elsif\", \"end\", \"ensure\", \"enum\", \"extend\", \"for\", \"fun\", \"if\",\n      \"include\", \"instance_sizeof\", \"lib\", \"macro\", \"module\", \"next\", \"of\", \"out\", \"pointerof\",\n      \"private\", \"protected\", \"rescue\", \"return\", \"require\", \"select\", \"sizeof\", \"struct\",\n      \"super\", \"then\", \"type\", \"typeof\", \"uninitialized\", \"union\", \"unless\", \"until\", \"when\", \"while\", \"with\",\n      \"yield\", \"__DIR__\", \"__END_LINE__\", \"__FILE__\", \"__LINE__\"\n    ]);\n    var atomWords = wordRegExp([\"true\", \"false\", \"nil\", \"self\"]);\n    var indentKeywordsArray = [\n      \"def\", \"fun\", \"macro\",\n      \"class\", \"module\", \"struct\", \"lib\", \"enum\", \"union\",\n      \"do\", \"for\"\n    ];\n    var indentKeywords = wordRegExp(indentKeywordsArray);\n    var indentExpressionKeywordsArray = [\"if\", \"unless\", \"case\", \"while\", \"until\", \"begin\", \"then\"];\n    var indentExpressionKeywords = wordRegExp(indentExpressionKeywordsArray);\n    var dedentKeywordsArray = [\"end\", \"else\", \"elsif\", \"rescue\", \"ensure\"];\n    var dedentKeywords = wordRegExp(dedentKeywordsArray);\n    var dedentPunctualsArray = [\"\\\\)\", \"\\\\}\", \"\\\\]\"];\n    var dedentPunctuals = new RegExp(\"^(?:\" + dedentPunctualsArray.join(\"|\") + \")$\");\n    var nextTokenizer = {\n      \"def\": tokenFollowIdent, \"fun\": tokenFollowIdent, \"macro\": tokenMacroDef,\n      \"class\": tokenFollowType, \"module\": tokenFollowType, \"struct\": tokenFollowType,\n      \"lib\": tokenFollowType, \"enum\": tokenFollowType, \"union\": tokenFollowType\n    };\n    var matching = {\"[\": \"]\", \"{\": \"}\", \"(\": \")\", \"<\": \">\"};\n\n    function tokenBase(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      // Macros\n      if (state.lastToken != \"\\\\\" && stream.match(\"{%\", false)) {\n        return chain(tokenMacro(\"%\", \"%\"), stream, state);\n      }\n\n      if (state.lastToken != \"\\\\\" && stream.match(\"{{\", false)) {\n        return chain(tokenMacro(\"{\", \"}\"), stream, state);\n      }\n\n      // Comments\n      if (stream.peek() == \"#\") {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n\n      // Variables and keywords\n      var matched;\n      if (stream.match(idents)) {\n        stream.eat(/[?!]/);\n\n        matched = stream.current();\n        if (stream.eat(\":\")) {\n          return \"atom\";\n        } else if (state.lastToken == \".\") {\n          return \"property\";\n        } else if (keywords.test(matched)) {\n          if (indentKeywords.test(matched)) {\n            if (!(matched == \"fun\" && state.blocks.indexOf(\"lib\") >= 0) && !(matched == \"def\" && state.lastToken == \"abstract\")) {\n              state.blocks.push(matched);\n              state.currentIndent += 1;\n            }\n          } else if ((state.lastStyle == \"operator\" || !state.lastStyle) && indentExpressionKeywords.test(matched)) {\n            state.blocks.push(matched);\n            state.currentIndent += 1;\n          } else if (matched == \"end\") {\n            state.blocks.pop();\n            state.currentIndent -= 1;\n          }\n\n          if (nextTokenizer.hasOwnProperty(matched)) {\n            state.tokenize.push(nextTokenizer[matched]);\n          }\n\n          return \"keyword\";\n        } else if (atomWords.test(matched)) {\n          return \"atom\";\n        }\n\n        return \"variable\";\n      }\n\n      // Class variables and instance variables\n      // or attributes\n      if (stream.eat(\"@\")) {\n        if (stream.peek() == \"[\") {\n          return chain(tokenNest(\"[\", \"]\", \"meta\"), stream, state);\n        }\n\n        stream.eat(\"@\");\n        stream.match(idents) || stream.match(types);\n        return \"variable-2\";\n      }\n\n      // Constants and types\n      if (stream.match(types)) {\n        return \"tag\";\n      }\n\n      // Symbols or ':' operator\n      if (stream.eat(\":\")) {\n        if (stream.eat(\"\\\"\")) {\n          return chain(tokenQuote(\"\\\"\", \"atom\", false), stream, state);\n        } else if (stream.match(idents) || stream.match(types) ||\n                   stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators)) {\n          return \"atom\";\n        }\n        stream.eat(\":\");\n        return \"operator\";\n      }\n\n      // Strings\n      if (stream.eat(\"\\\"\")) {\n        return chain(tokenQuote(\"\\\"\", \"string\", true), stream, state);\n      }\n\n      // Strings or regexps or macro variables or '%' operator\n      if (stream.peek() == \"%\") {\n        var style = \"string\";\n        var embed = true;\n        var delim;\n\n        if (stream.match(\"%r\")) {\n          // Regexps\n          style = \"string-2\";\n          delim = stream.next();\n        } else if (stream.match(\"%w\")) {\n          embed = false;\n          delim = stream.next();\n        } else if (stream.match(\"%q\")) {\n          embed = false;\n          delim = stream.next();\n        } else {\n          if(delim = stream.match(/^%([^\\w\\s=])/)) {\n            delim = delim[1];\n          } else if (stream.match(/^%[a-zA-Z_\\u009F-\\uFFFF][\\w\\u009F-\\uFFFF]*/)) {\n            // Macro variables\n            return \"meta\";\n          } else if (stream.eat('%')) {\n            // '%' operator\n            return \"operator\";\n          }\n        }\n\n        if (matching.hasOwnProperty(delim)) {\n          delim = matching[delim];\n        }\n        return chain(tokenQuote(delim, style, embed), stream, state);\n      }\n\n      // Here Docs\n      if (matched = stream.match(/^<<-('?)([A-Z]\\w*)\\1/)) {\n        return chain(tokenHereDoc(matched[2], !matched[1]), stream, state)\n      }\n\n      // Characters\n      if (stream.eat(\"'\")) {\n        stream.match(/^(?:[^']|\\\\(?:[befnrtv0'\"]|[0-7]{3}|u(?:[0-9a-fA-F]{4}|\\{[0-9a-fA-F]{1,6}\\})))/);\n        stream.eat(\"'\");\n        return \"atom\";\n      }\n\n      // Numbers\n      if (stream.eat(\"0\")) {\n        if (stream.eat(\"x\")) {\n          stream.match(/^[0-9a-fA-F_]+/);\n        } else if (stream.eat(\"o\")) {\n          stream.match(/^[0-7_]+/);\n        } else if (stream.eat(\"b\")) {\n          stream.match(/^[01_]+/);\n        }\n        return \"number\";\n      }\n\n      if (stream.eat(/^\\d/)) {\n        stream.match(/^[\\d_]*(?:\\.[\\d_]+)?(?:[eE][+-]?\\d+)?/);\n        return \"number\";\n      }\n\n      // Operators\n      if (stream.match(operators)) {\n        stream.eat(\"=\"); // Operators can follow assign symbol.\n        return \"operator\";\n      }\n\n      if (stream.match(conditionalOperators) || stream.match(anotherOperators)) {\n        return \"operator\";\n      }\n\n      // Parens and braces\n      if (matched = stream.match(/[({[]/, false)) {\n        matched = matched[0];\n        return chain(tokenNest(matched, matching[matched], null), stream, state);\n      }\n\n      // Escapes\n      if (stream.eat(\"\\\\\")) {\n        stream.next();\n        return \"meta\";\n      }\n\n      stream.next();\n      return null;\n    }\n\n    function tokenNest(begin, end, style, started) {\n      return function (stream, state) {\n        if (!started && stream.match(begin)) {\n          state.tokenize[state.tokenize.length - 1] = tokenNest(begin, end, style, true);\n          state.currentIndent += 1;\n          return style;\n        }\n\n        var nextStyle = tokenBase(stream, state);\n        if (stream.current() === end) {\n          state.tokenize.pop();\n          state.currentIndent -= 1;\n          nextStyle = style;\n        }\n\n        return nextStyle;\n      };\n    }\n\n    function tokenMacro(begin, end, started) {\n      return function (stream, state) {\n        if (!started && stream.match(\"{\" + begin)) {\n          state.currentIndent += 1;\n          state.tokenize[state.tokenize.length - 1] = tokenMacro(begin, end, true);\n          return \"meta\";\n        }\n\n        if (stream.match(end + \"}\")) {\n          state.currentIndent -= 1;\n          state.tokenize.pop();\n          return \"meta\";\n        }\n\n        return tokenBase(stream, state);\n      };\n    }\n\n    function tokenMacroDef(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      var matched;\n      if (matched = stream.match(idents)) {\n        if (matched == \"def\") {\n          return \"keyword\";\n        }\n        stream.eat(/[?!]/);\n      }\n\n      state.tokenize.pop();\n      return \"def\";\n    }\n\n    function tokenFollowIdent(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      if (stream.match(idents)) {\n        stream.eat(/[!?]/);\n      } else {\n        stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators);\n      }\n      state.tokenize.pop();\n      return \"def\";\n    }\n\n    function tokenFollowType(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      stream.match(types);\n      state.tokenize.pop();\n      return \"def\";\n    }\n\n    function tokenQuote(end, style, embed) {\n      return function (stream, state) {\n        var escaped = false;\n\n        while (stream.peek()) {\n          if (!escaped) {\n            if (stream.match(\"{%\", false)) {\n              state.tokenize.push(tokenMacro(\"%\", \"%\"));\n              return style;\n            }\n\n            if (stream.match(\"{{\", false)) {\n              state.tokenize.push(tokenMacro(\"{\", \"}\"));\n              return style;\n            }\n\n            if (embed && stream.match(\"#{\", false)) {\n              state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n              return style;\n            }\n\n            var ch = stream.next();\n\n            if (ch == end) {\n              state.tokenize.pop();\n              return style;\n            }\n\n            escaped = embed && ch == \"\\\\\";\n          } else {\n            stream.next();\n            escaped = false;\n          }\n        }\n\n        return style;\n      };\n    }\n\n    function tokenHereDoc(phrase, embed) {\n      return function (stream, state) {\n        if (stream.sol()) {\n          stream.eatSpace()\n          if (stream.match(phrase)) {\n            state.tokenize.pop();\n            return \"string\";\n          }\n        }\n\n        var escaped = false;\n        while (stream.peek()) {\n          if (!escaped) {\n            if (stream.match(\"{%\", false)) {\n              state.tokenize.push(tokenMacro(\"%\", \"%\"));\n              return \"string\";\n            }\n\n            if (stream.match(\"{{\", false)) {\n              state.tokenize.push(tokenMacro(\"{\", \"}\"));\n              return \"string\";\n            }\n\n            if (embed && stream.match(\"#{\", false)) {\n              state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n              return \"string\";\n            }\n\n            escaped = embed && stream.next() == \"\\\\\";\n          } else {\n            stream.next();\n            escaped = false;\n          }\n        }\n\n        return \"string\";\n      }\n    }\n\n    return {\n      startState: function () {\n        return {\n          tokenize: [tokenBase],\n          currentIndent: 0,\n          lastToken: null,\n          lastStyle: null,\n          blocks: []\n        };\n      },\n\n      token: function (stream, state) {\n        var style = state.tokenize[state.tokenize.length - 1](stream, state);\n        var token = stream.current();\n\n        if (style && style != \"comment\") {\n          state.lastToken = token;\n          state.lastStyle = style;\n        }\n\n        return style;\n      },\n\n      indent: function (state, textAfter) {\n        textAfter = textAfter.replace(/^\\s*(?:\\{%)?\\s*|\\s*(?:%\\})?\\s*$/g, \"\");\n\n        if (dedentKeywords.test(textAfter) || dedentPunctuals.test(textAfter)) {\n          return config.indentUnit * (state.currentIndent - 1);\n        }\n\n        return config.indentUnit * state.currentIndent;\n      },\n\n      fold: \"indent\",\n      electricInput: wordRegExp(dedentPunctualsArray.concat(dedentKeywordsArray), true),\n      lineComment: '#'\n    };\n  });\n\n  CodeMirror.defineMIME(\"text/x-crystal\", \"crystal\");\n});\n"],
  "mappings": "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",
  "names": ["CodeMirror"]
}
